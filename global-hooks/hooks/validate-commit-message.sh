#!/bin/bash
#
# Conventional Commit Message Validator
#
# Usage: validate-commit-message.sh [SHA]
#   SHA: Optional commit SHA to validate (defaults to HEAD)
#
# Exit codes:
#   0 = Valid
#   1 = Warning (non-blocking)
#   2 = Error (blocks the commit)
#

# --- Hook Input Filtering ---
# When called as a PostToolUse hook, stdin contains JSON with tool_input.
# Only proceed for git commit commands; exit 0 for everything else.
if ! [ -t 0 ]; then
    INPUT=$(cat)
    COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty' 2>/dev/null || true)
    if [[ ! "$COMMAND" =~ ^git[[:space:]]+commit ]]; then
        exit 0
    fi
fi

# Early exit if not in a git repository
if ! git rev-parse --git-dir &>/dev/null; then
    exit 0
fi

# Get commit message (optional SHA argument, defaults to HEAD)
SHA="${1:-HEAD}"
COMMIT_MSG=$(git log -1 --pretty=%B "$SHA" 2>/dev/null || echo "")

# If we can't get a commit message, this isn't a git commit operation
if [[ -z "$COMMIT_MSG" ]]; then
    exit 0
fi

# Now enable strict error handling for the actual validation
set -euo pipefail

# Extract subject line (first line)
SUBJECT=$(echo "$COMMIT_MSG" | head -1)

# --- Emoji Detection ---

# Check for common emoji patterns (Unicode ranges and GitHub shortcodes)
if echo "$COMMIT_MSG" | grep -qP '[\x{1F300}-\x{1F9FF}]|[\x{2600}-\x{27BF}]|[\x{1F600}-\x{1F64F}]|[\x{1F680}-\x{1F6FF}]|[\x{2300}-\x{23FF}]|[\x{2B50}]|[\x{1F100}-\x{1F1FF}]' 2>/dev/null; then
    echo "ERROR: Commit message contains emojis"
    echo "Remove all emoji characters from the commit message."
    exit 2
fi

# Check for GitHub emoji shortcodes like :sparkles: :bug: :fire:
if echo "$COMMIT_MSG" | grep -qE ':[a-z_]+:'; then
    echo "ERROR: Commit message contains emoji shortcodes (e.g., :sparkles:, :bug:)"
    echo "Remove all :emoji: shortcodes from the commit message."
    exit 2
fi

# --- Meta-Commentary Detection ---

# Check for Co-authored-by (especially Claude references)
if echo "$COMMIT_MSG" | grep -qiE "co-authored-by.*claude|co-authored-by.*anthropic|co-authored-by.*ai|co-authored-by.*assistant"; then
    echo "ERROR: Commit contains AI/Claude co-author attribution"
    echo "Remove 'Co-authored-by' lines referencing Claude or AI assistants."
    exit 2
fi

# Check for any Co-authored-by (warn, don't block)
if echo "$COMMIT_MSG" | grep -qiE "^co-authored-by:"; then
    echo "WARNING: Commit contains Co-authored-by trailer"
    echo "Consider whether this attribution is necessary."
fi

# Check for "Generated by" or similar AI meta-commentary
if echo "$COMMIT_MSG" | grep -qiE "generated (by|with|using)|created (by|with) (claude|ai|gpt|llm|copilot)|assisted by|written by (claude|ai|assistant)"; then
    echo "ERROR: Commit contains AI generation attribution"
    echo "Remove meta-commentary about how the commit was generated."
    exit 2
fi

# --- Format Validation ---

# Valid types per Conventional Commits spec
VALID_TYPES="feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert"

# Full pattern breakdown:
#   ^                       - Start of line
#   (feat|fix|...)          - Type (required)
#   (\([a-z0-9_-]+\))?      - Scope (optional, lowercase alphanumeric with - and _)
#   !?                      - Breaking change indicator (optional)
#   :                       - Colon (required)
#   [ ]                     - Single space (required)
#   .+                      - Description (required, at least 1 char)
#   $                       - End of line
PATTERN="^($VALID_TYPES)(\([a-z0-9_-]+\))?!?: .+$"

if ! echo "$SUBJECT" | grep -qE "$PATTERN"; then
    echo "ERROR: Commit message does not follow Conventional Commits format"
    echo ""
    echo "Expected: <type>(<scope>): <description>"
    echo ""
    echo "Valid types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert"
    echo ""
    echo "Valid formats:"
    echo "  type: description"
    echo "  type(scope): description"
    echo "  type!: description           (breaking change)"
    echo "  type(scope)!: description    (breaking change with scope)"
    echo ""
    echo "Got: $SUBJECT"
    exit 2
fi

# --- Length Validation ---

SUBJECT_LENGTH=${#SUBJECT}
if [[ $SUBJECT_LENGTH -gt 72 ]]; then
    echo "ERROR: Subject line too long ($SUBJECT_LENGTH chars, max 72)"
    echo "Got: $SUBJECT"
    exit 2
elif [[ $SUBJECT_LENGTH -gt 50 ]]; then
    echo "WARNING: Subject line is $SUBJECT_LENGTH chars (recommended max: 50)"
fi

# --- Extract Description ---

# Remove type, scope, and breaking indicator to get description
DESCRIPTION=$(echo "$SUBJECT" | sed -E "s/^($VALID_TYPES)(\([a-z0-9_-]+\))?!?: //")

# --- Style Checks ---

WARNINGS=()

# Check for lowercase start (description should start lowercase)
if echo "$DESCRIPTION" | grep -qE "^[A-Z]"; then
    WARNINGS+=("Description starts with uppercase (prefer lowercase)")
fi

# Check for trailing period
if echo "$DESCRIPTION" | grep -qE "\.$"; then
    WARNINGS+=("Description ends with period (omit trailing punctuation)")
fi

# --- Tense Validation (Present Indicative vs Imperative) ---

# Extract first word of description
FIRST_WORD=$(echo "$DESCRIPTION" | awk '{print $1}' | tr '[:upper:]' '[:lower:]')

# Common imperative verbs (should be present indicative: adds, fixes, etc.)
IMPERATIVE_VERBS="add|fix|update|remove|change|refactor|implement|create|delete|move|rename|improve|enhance|optimize|resolve|prevent|enable|disable|allow|support|handle|convert|merge|split|extract|introduce|deprecate|drop|bump|upgrade|downgrade|revert|restore|clean|simplify|clarify|document|test|validate|verify|ensure|make|set|get|use|apply|include|exclude|extend|override|wrap|unwrap"

# Check if first word is imperative (doesn't end in 's')
if echo "$FIRST_WORD" | grep -qE "^($IMPERATIVE_VERBS)$"; then
    # Suggest the present indicative form
    case "$FIRST_WORD" in
        fix) SUGGESTED="fixes" ;;
        apply) SUGGESTED="applies" ;;
        simplify) SUGGESTED="simplifies" ;;
        clarify) SUGGESTED="clarifies" ;;
        verify) SUGGESTED="verifies" ;;
        *) SUGGESTED="${FIRST_WORD}s" ;;
    esac

    echo "ERROR: Use present indicative tense, not imperative"
    echo "  Got:      '$FIRST_WORD ...'"
    echo "  Expected: '$SUGGESTED ...'"
    echo ""
    echo "Examples:"
    echo "  'adds feature' not 'add feature'"
    echo "  'fixes bug' not 'fix bug'"
    echo "  'updates deps' not 'update deps'"
    exit 2
fi

# --- Body Validation (if present) ---

BODY=$(echo "$COMMIT_MSG" | tail -n +3)
if [[ -n "$BODY" ]]; then
    # Count non-empty lines in body
    BODY_LINES=$(echo "$BODY" | grep -c "." || true)

    # Check for file listings (common anti-pattern)
    if echo "$BODY" | grep -qE "^[- *] .*\.(py|js|ts|go|rs|java|rb|md|json|yaml|yml|toml)"; then
        WARNINGS+=("Body lists files—let the diff show what changed")
    fi

    # Check for "Changes:", "Benefits:", etc. sections
    if echo "$BODY" | grep -qiE "^(Changes|Benefits|Files|Modified|Updated):"; then
        WARNINGS+=("Body contains listing sections—focus on 'why', not 'what'")
    fi

    # Check for "what" explanations (describing changes instead of motivation)
    if echo "$BODY" | grep -qiE "^(add|adds|added|update|updates|updated|remove|removes|removed|change|changes|changed)"; then
        WARNINGS+=("Body describes 'what' changed—explain 'why' instead")
    fi

    # Length warnings
    if [[ $BODY_LINES -gt 3 ]]; then
        WARNINGS+=("Body is $BODY_LINES lines (recommended: 2-3 lines max)")
    fi

    # Check line length in body (72 char recommended)
    while IFS= read -r line; do
        LINE_LENGTH=${#line}
        if [[ $LINE_LENGTH -gt 72 ]]; then
            WARNINGS+=("Body line exceeds 72 chars ($LINE_LENGTH): wrap at 72")
            break  # Only warn once
        fi
    done <<< "$BODY"
fi

# --- Output Results ---

if [[ ${#WARNINGS[@]} -gt 0 ]]; then
    echo "WARNINGS:"
    for warning in "${WARNINGS[@]}"; do
        echo "  - $warning"
    done
    echo ""
fi

echo "✓ Commit message valid: $SUBJECT"
exit 0
